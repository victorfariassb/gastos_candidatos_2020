# -*- coding: utf-8 -*-
"""despesas_prefeitos_2020.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_hMf85H_P-W-iRkvRF2Brt7b3vcmLjjE
"""

# ----------------------------------------[ Tarefa 1 ]-----------------------------------------
#        GRUPO: Layane Serrano, Luiza Ferraz, Ricardo Grinbaum, Sara Magalhães e Victor Farias
# ---------------------------------------------------------------------------------------------

# primeiro, importamos o pandas para analisar a base de dados

import pandas as pd

# depois, pedimos para o computador ler o arquivo

df = pd.read_csv('despesas_2020_abridged.txt')

# e pedimos para ele nos mostrar que dados são esses

df

"""Levando em conta os dados acima, escolhemos três variáveis para rodar o `.describe()` nelas, que são: **UF**, **município** e **partido**.

# Agrupados por município
"""

#  primeiro, fizemos um filtro na base de dados para pegar apenas 
#  as variáveis que queríamos utilizar ('muni_code' e 'valor')

municipio = df[['muni_code', 'valor']]

#  pedimos para ele agrupar por 'munic_code' e calcular os valores em cima disso
municipio = municipio.groupby(['muni_code']).describe()

#  e pedimos para exibir o resultado
municipio

"""# Agrupados por UF"""

#  repetimos o primeiro passo de escolher as variáveis, neste caso 'uf' e 'valor'

estado = df[['uf', 'valor']]

#  dessa vez, fizemos o .describe() mas também pedimos para ele resetar o index, 
#  porque o resultado final anterior ficava com um cabeçalho de duas linhas
estado = estado.groupby(['uf']).describe()
estado = estado.reset_index()
colunas = ['uf', 'count', 'mean', 'std', 'min', '25%', '50%', '75%', 'max']
estado.columns=colunas

# e pedimos para exibir o resultado final
estado

"""# Agrupados por partido"""

#  agora só repetimos o mesmo código anterior, alterando a variável 'uf' para 'partido'

partido = df[['partido', 'valor']]
partido = partido.groupby(['partido']).describe()
partido = partido.reset_index()
colunas2 = ['partido', 'count', 'mean', 'std', 'min', '25%', '50%', '75%', 'max']
partido.columns=colunas2

partido

"""Finalizadas as tabelas, fomos para o gráfico de dispersão:

# Dispersão
"""

#  para isso, usamos a biblitoeca plotly.express

import plotly.express as px
fig = px.scatter(
    estado, x="mean", y="count",
    hover_name="partido", hover_data=["mean", "count"]
    )
fig.show()

#  LENDO O GRÁFICO:
#
#  Pegamos a quantidade de despesas registradas (y) e a média dessas despesas em relação a cada partido (x)
#  O partido Novo, por exemplo, registrou poucas despesas (y), mas a média do valor gasto delas é muito superior ao dos outros (x)
#
#  OBS: O gráfico é interativo, então é só passar o mouse para ver que partido está em uma bolinha

"""Em seguida, fomos para o histograma, que foi uma das partes mais complexas. Fizemos uma primeira versão, mas queríamos deixá-la mais visível, o que nos levou a uma segunda versão.

# Histograma
"""

#  para a nossa primeira tentativa, utilizamos o altair

import altair as alt

#  pegamos o código abaixo dentro da galeria de exemplos da documentação da biblitoeca
#  e preenchemos com a variável que queríamos analisar: a média de um dos descibres acima
#  nesse caso, escolhemos o .describe() usado para os partidos, salvo na variável 'partido'

alt.Chart(partido).mark_bar().encode(
    x = alt.X('mean', bin=True),
    y= "count()",
).interactive()

#  LENDO O GRÁFICO:
#
#  'count' representa a quantidade de despesas registradas e 'mean' o valor médio delas.
#  ou seja, a barra mais alta está dizendo que existem 9 partidos em que a média das despesas
#  deles está entre 1.000 e 1.400 — sendo assim, esse é o valor mais frequente nesse grupo.

"""Mas percebemos um problema: a leitura do gráfico não estava tão natural. Um possível motivo é que usamos um histograma, que já é um gráfico que condensa dados, com uma base já condensada — aquela dos dados calculados via `.describe()`.

Mas tínhamos escolhido fazer desta forma inicialmente porque quando testamos o gráfico do Altair direto na base de dados original `df` apareceu um erro ao rodar o código, dizendo que a base era grande demais.

Algumas discussões depois, chegamos a um consenso: usar uma outra biblioteca para conseguir pegar os dados originais, diretamente da base `df`, e fazer uma análise melhor.
"""

#  primeiro, decidimos fazer um recorte: apenas estados do Sudeste, que eram os que tinham mais registros

#  então, fizemos um filtro

estados = ['RJ', 'SP', 'ES', 'MG']
filtrar_se = df[df.uf.isin(estados)]

#  e pedimos para ver como ele ficou
filtrar_se

#  depois, importamos as bibliotecas seaborn e matplotlib 
#  (especificamente a função rcparams, para configurar o tamanho do gráfico gerado)

import seaborn as sns
from matplotlib import rcParams

rcParams['figure.figsize'] = 11.7,8.27

#  pedimos para ela separar pelos valores das despesas e colorir por 'uf',
#  além de filtrar pelos valores abaixo de 2.000 e com uma amostra
#  aleatória de 15.000 registros (ambas as medidas por causa do tamanho da base)
sns.histplot(x = 'valor', hue = 'uf', multiple="stack", data = filtrar_se[filtrar_se.valor < 2000].sample(15000))


#  LENDO O GRÁFICO:
#
#  o gráfico resultante mostra quantas vezes os estados (y) registraram um 
#  determinado valor de despesa (x).
#
#  suponhamos que eu queira saber quantos registros de despesas de 10.000
#  tiveram no RJ: eu vou pegar a frequência total (500) e subtrair dos
#  demais estados. no gráfico em questão, não existe a funcionalidade
#  de interação. ela precisaria ser acrescentada para chegar a esse
#  resultado final com precisão.

"""Por fim, para a tabela de distribuição, apenas filtramos o `.describe()` feito no início para os estados.

# Tabela de distribuição
"""

tabela_distribuicao = estado.reset_index()
colunas = ['uf', 'count', 'mean', 'std', 'min', '25%', '50%', '75%', 'max']
tabela_distribuicao.columns=colunas
tabela_distribuicao_selecionada = tabela_distribuicao[['uf','25%', '50%', '75%']]

tabela_distribuicao_selecionada